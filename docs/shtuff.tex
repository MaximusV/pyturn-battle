\documentclass[11pt]{report}

\title{\textbf{pyturn}\\
An Open-Source Turn-Based Battle Framework}
\author{Max Vizard | 09006863\\
		James Heslin | 09006132\\}
\date{November 23, 2012}
\begin{document}

\maketitle

\tableofcontents{}
\pagebreak

\section{Narrative}
You and a small team of friends have decided to construct an open-source framework/engine for turn based, party-centric battle games. A sample implementation should be included to help other developers understand the framework. 

\section{Requirements}
	\subsection{Functional}
	\begin{itemize}
			\item{A system for two or more ‘parties’ of at least one character to engage in some form of turn based competition.}
			\item{Each party member takes a turn in the competition, during which they can perform set actions.}
			\item{Party members have their own individual attributes that influence their performance and possibly the turn order.}
			\item{An interface for at least one player to interact with the system, controlling one or more party members, allowing for action selection, result output and display of game state.}
			\item{A method of storing game state and predetermined gameplay variables.}
			%\item{A method of persisting game state if program is ended and allowing the player to continue from that state when the program is run again.}
	\end{itemize}
	\subsection{Non-Functional}
	\begin{itemize}
		\item{Portability}
		\item{Extensibility}
		\item{Interoperability}
		\item{Quality}
		\item{Comprehensibility}
	\end{itemize}

\section{Architectural Use Cases}
	\subsection{Asynchronous rock, paper, scissors game}
	Developer wants to create a game for two people to play the rock, paper, scissors game together on the same computer, taking turns to enter their choice and then evaluating a winner as though the choices had taken place at the same time. 
	\subsection{Monster battle game (in the style of Pok\'{e}mon\textregistered)}
	Developer wants to create a game where the player controls a group of monsters in battles with other groups of monsters. Each monster has a number of moves they can perform, but each move can only be performed a certain number of times during a single battle. Each turn, the player can choose to switch out their monster or make a move. The game is won when one player’s monsters are all incapacitated.
	\subsection{Digital implementation of trading card type games}
	Developer wants a game where players can take turns placing cards on a virtual table, similar to games like Magic: the Gathering. Cards can have various effects on either player, such as increasing or decreasing their ‘life’ score, allowing them to draw extra cards from a deck, etc.

\section{Design Patterns}
	\subsection{Bridge Design Pattern}
	Our project is quite a simple game framework, which makes it ideal for multiple platforms. Not wanting to clutter our logic classes with switch cases depending on platform, we researched patterns that would allow us to separate display from logic easily. The Bridge Design Pattern is a method of separating platform- or implementation-specific functionality from independent functionality. It is a good example of the software design principle, \emph{encapsulate what varies}. In the ideal case, it decouples the abstraction from the implementation altogether. One side of the 'bridge' is our independent implementation, which has a reference to an abstraction (in the form of an interface or abstract class). This is the other side of the bridge. In our independent implementation, wherever we would normally need to differ our implementation based on the variables in the system, we can instead call upon the abstraction to perform the system-specific functions. We have to trust the abstraction and its subclasses to do this. An example of where to use the Bridge pattern is in programming a game that should be playable using a terminal emulator or through a graphical window. The independent implementation might be a GameLogic abstract class, and the display abstraction a GameDisplay abstract class. The bridge separates any display code from the methods (such as \texttt{display("some text")}), which are called by GameLogic. Not only this, but the same \texttt{GameDisplay.display()} calls will display text in a terminal emulator, a GTK+ window, or whatever graphical user interface subclass is required. An alternative to the Bridge pattern is the Adaptor, which is similar, but distinct. While the Bridge has its abstraction and implementation tightly coupled, the Adaptor places another class or interface between the two, acting as an intermediary. We decided not to use the Adaptor, as more than one layer between the implementation and the abstraction is not necessary in our application. The Bridge supports our quality attributes of comprehensibility, portability, and extensibility. Keeping logic code free of out-of-band functionality like displaying text onscreen allows our code to be much more understandable. The Bridge is also inherently supportive of portability and extensibility, because it makes it easy for client developers to change or add implementations on the abstraction side.
	
	\subsection{State Design Pattern}
	Most games of any kind have multiple states, which change how they behave. The State Design Pattern aims to encapsulate those states and abstract away the different behaviours. In our game, we use the State pattern to manage the behaviour of two different scenarios: the user in the menu, before starting the game, and the user playing the game. Both states implement the same interface, allowing the main game class not to care which state is which for the purposes of getting input and displaying output. We could have used the similar Strategy pattern here, but Strategy is more useful for doing one thing than it is for modelling a scenario. The State pattern fits well in our application because it supports our quality attributes of extensibility and comprehensibility. Client developers can easily add new states to the game if they want to model additional scenarios. In addition to this, the State pattern is quite easy to understand, so it lowers the barrier to newer developers wishing to use our framework.
	
	\subsection{Delegates}
	Delegation is a method of programming to interfaces, rather than implementation. At its most basic, compositional delegation involves class A calling a method in class B, which delegates to a method in class C. Class A never knows that C exists, which keeps C's logic well-encapsulated. We use delegation a lot in our game, as it supports our non-functional requirement of code quality. Delegation allows for an application to be decomposed into modules and layers quite easily, and then for these modules and layers to call each other in a chain in order to perform a function. For example, in our game state class, we call a method that gets all the available options for the user at this particular moment. Unbeknownst to the game state class, the game engine retrieves the options from the game variables class. This also fits well with our multi-tiered architectural pattern. 

	\subsection{Decorator Pattern}
	The decorator design pattern allows developers to attach additional functionality to an object at runtime, providing a less rigid alternative to inheritance. By extending functionality while adhering to interfaces, this pattern supports the quality attribute of extensibility without compromising readability and comprehensibility. A suitable use case for this pattern exists in our system. Players can perform certain actions, which are represented by concrete subclasses of the Action class. By providing a decorator interface for this class, the framework will allow client developers to quickly and easily extend the functionality of any given action, with a variety of simple decorator classes. This will prevent subclass explosion, and may also decompose a lot of complex features into smaller, more comprehensible classes. The decorator relies on delegation to defer logical operations to another class, simplifying the operational logic of each decorator. 

	\subsection{Observer Pattern}
	The Observer Pattern is used in situations where changing one object requires changes to one or more other objects. Instead of having tight coupling between these classes, this pattern provides a flexible interface to model such a relationship. The subject is the name used to describe the class that changes state upon which one or more observers depend. The subject should be able to inform observers of changes to its state without knowledge about those classes. The observers need to define an interface for accepting updates from any subjects that it subscribes to. The term publish-subscribe is often used to describe this style of interaction. The abstract coupling of the subject and its observers allow the pattern to cross different layers of abstraction within an architectural pattern, without breaking the layered system. This is particularly relevant to our framework, where logic level classes may wish to subscribe to changes in data layer subjects. Some issues can arise with the implementation of this pattern, and so it is important to carefully consider how the pattern can be applied to the situation at hand. Due to the nature of the abstract coupling of observers, updates to the subject may incur heavy overheads due to the subsequent notification to all observers. Therefore, updates to the subject should be carefully managed. A decision should be made as to whether the subject calls notify in every mutator/state setting operation, or whether to depend on clients to call notify at an appropriate time. The flexibility of the notification process, often a useful feature of the pattern, may lead to unintended or unnecessary updates. Another issue lies in the update protocol used by the subject to notify subscribers of changes. The subject often simply passes a reference to itself to the update function of its subscribers, leaving them to infer what has changed about it. If the subject is complex, this may be labour intensive and time consuming. Therefore, it is common practise to define a Change-Manager class to carefully manage these interactions. In our project, we use the Observer pattern to publish changes to variables to the database.

	\subsection{Factory Method Pattern}
	The factory method pattern belongs the grouping of design patterns called creational patterns. These patterns are concerned with the instantiation of objects within a framework and how to maintain quality attributes such as extensibility. These patterns support the Open Closed Principle; closed for modification, open for extension. The main point of the factory method is to defer object instantiation to a method, which is left abstract so that client developers can specify which subclass of the object to instantiate when they implement the abstract class. A classic example would be a class that needs to instantiate some Product but the application designers don’t know in advance what type of ConcreteProduct that may be needed. An alternative pattern is the Builder pattern which abstracts out the construction of a complex object and provides the same benefits of deferring object instantiation, albeit with more overhead. We felt that the Builder pattern was too complex for our needs and required more class definitions than was strictly necessary. 
	
\end{document}

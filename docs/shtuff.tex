\documentclass[11pt]{report}

\title{\textbf{pyturn}\\
An Open-Source Turn-Based Battle Framework}
\author{Max Vizard | 09006863\\
		James Heslin | 09006132\\}
\date{November 23, 2012}
\begin{document}

\maketitle

\tableofcontents{}
\pagebreak

\section{Narrative}
You and a small team of friends have decided to construct an open-source framework/engine for turn based, party-based battle games. A sample implementation should be included to help other developers understand the framework. 

\section{Requirements}
	\subsection{Functional}
	\begin{itemize}
			\item{A system for two or more ‘parties’ of at least one character to engage in some form of turn based competition.}
			\item{Each party member takes a turn in the competition, during which they can perform set actions.}
			\item{Party members have their own individual attributes that influence their performance and possibly the turn order.}
			\item{An interface for at least one player to interact with the system, controlling one or more party members, allowing for action selection, result output and display of game state.}
			\item{A method of storing game state and predetermined gameplay variables.}
			%\item{A method of persisting game state if program is ended and allowing the player to continue from that state when the program is run again.}
	\end{itemize}
	\subsection{Non-Functional}
	\begin{itemize}
		\item{Portability}
		\item{Extensibility}
		\item{Interoperability}
		\item{Quality}
		\item{Comprehensibility}
		\item{Short development cycle}
	\end{itemize}

\section{Architectural Use Cases}
	\subsection{Asynchronous rock, paper, scissors game}
	Developer wants to create a game for two people to play the rock, paper, scissors game together on the same computer, taking turns to enter their choice and then evaluating a winner as though the choices had taken place at the same time. 
	\subsection{Monster battle game (in the style of Pok\'{e}mon\textregistered)}
	Developer wants to create a game where the player controls a group of monsters in battles with other groups of monsters. Each monster has a number of moves they can perform, but each move can only be performed a certain number of times during a single battle. Each turn, the player can choose to switch out their monster or make a move. The game is won when one player’s monsters are all incapacitated.
	\subsection{Digital implementation of trading card type games}
	Developer wants a game where players can take turns placing cards on a virtual table, similar to games like Magic: the Gathering. Cards can have various effects on either player, such as increasing or decreasing their ‘life’ score, allowing them to draw extra cards from a deck, etc.

\section{Design Patterns}
	\subsection{Bridge Design Pattern}
	Our project is quite a simple game framework, which makes it ideal for multiple platforms. Not wanting to clutter our logic classes with switch cases depending on platform, we researched patterns that would allow us to separate display from logic easily. The Bridge Design Pattern is a method of separating platform- or implementation-specific functionality from independent functionality. It is a good example of the software design principle, \emph{encapsulate what varies}. In the ideal case, it decouples the abstraction from the implementation altogether. One side of the 'bridge' is our independent implementation, which has a reference to an abstraction (in the form of an interface or abstract class). This is the other side of the bridge. In our independent implementation, wherever we would normally need to differ our implementation based on the variables in the system, we can instead call upon the abstraction to perform the system-specific functions. We have to trust the abstraction and its subclasses to do this. An example of where to use the Bridge pattern is in programming a game that should be playable using a terminal emulator or through a graphical window. The independent implementation might be a GameLogic abstract class, and the display abstraction a GameDisplay abstract class. The bridge separates any display code from the methods (such as \texttt{display("some text")}), which are called by GameLogic. Not only this, but the same \texttt{GameDisplay.display()} calls will display text in a terminal emulator, a GTK+ window, or whatever graphical user interface subclass is required. An alternative to the Bridge pattern is the Adaptor, which is similar, but distinct. While the Bridge has its abstraction and implementation tightly coupled, the Adaptor places another class or interface between the two, acting as an intermediary. We decided not to use the Adaptor, as more than one layer between the implementation and the abstraction is not necessary in our application. The Bridge supports our quality attributes of comprehensibility, portability, and extensibility. Keeping logic code free of out-of-band functionality like displaying text onscreen allows our code to be much more understandable. The Bridge is also inherently supportive of portability and extensibility, because it makes it easy for client developers to change or add implementations on the abstraction side.
	
	\subsection{State Design Pattern}
	Most games of any kind have multiple states, which change how they behave. The State Design Pattern aims to encapsulate those states and abstract away the different behaviours. In our game, we use the State pattern to manage the behaviour of two different scenarios: the user in the menu, before starting the game, and the user playing the game. Both states implement the same interface, allowing the main game class not to care which state is which for the purposes of getting input and displaying output. We could have used the similar Strategy pattern here, but Strategy is more useful for doing one thing than it is for modelling a scenario. The State pattern fits well in our application because it supports our quality attributes of extensibility and comprehensibility. Client developers can easily add new states to the game if they want to model additional scenarios. In addition to this, the State pattern is quite easy to understand, so it lowers the barrier to newer developers wishing to use our framework.
	
	\subsection{Delegates}
	Delegation is a method of programming to interfaces, rather than implementation. At its most basic, compositional delegation involves class A calling a method in class B, which delegates to a method in class C. Class A never knows that C exists, which keeps C's logic well-encapsulated. We use delegation a lot in our game, as it supports our non-functional requirement of code quality. Delegation allows for an application to be decomposed into modules and layers quite easily, and then for these modules and layers to call each other in a chain in order to perform a function. For example, in our game state class, we call a method that gets all the available options for the user at this particular moment. Unbeknownst to the game state class, the game engine retrieves the options from the game variables class. This also fits well with our multi-tiered architectural pattern. 

	\subsection{Decorator Pattern}
	The decorator design pattern allows developers to attach additional functionality to an object at runtime, providing a less rigid alternative to inheritance. By extending functionality while adhering to interfaces, this pattern supports the quality attribute of extensibility without compromising readability and comprehensibility. A suitable use case for this pattern exists in our system. Players can perform certain actions, which are represented by concrete subclasses of the Action class. By providing a decorator interface for this class, the framework will allow client developers to quickly and easily extend the functionality of any given action, with a variety of simple decorator classes. This will prevent subclass explosion, and may also decompose a lot of complex features into smaller, more comprehensible classes. The decorator relies on delegation to defer logical operations to another class, simplifying the operational logic of each decorator. 

	\subsection{Observer Pattern}
	The Observer Pattern is used in situations where changing one object requires changes to one or more other objects. Instead of having tight coupling between these classes, this pattern provides a flexible interface to model such a relationship. The subject is the name used to describe the class that changes state upon which one or more observers depend. The subject should be able to inform observers of changes to its state without knowledge about those classes. The observers need to define an interface for accepting updates from any subjects that it subscribes to. The term publish-subscribe is often used to describe this style of interaction. The abstract coupling of the subject and its observers allow the pattern to cross different layers of abstraction within an architectural pattern, without breaking the layered system. This is particularly relevant to our framework, where logic level classes may wish to subscribe to changes in data layer subjects. Some issues can arise with the implementation of this pattern, and so it is important to carefully consider how the pattern can be applied to the situation at hand. Due to the nature of the abstract coupling of observers, updates to the subject may incur heavy overheads due to the subsequent notification to all observers. Therefore, updates to the subject should be carefully managed. A decision should be made as to whether the subject calls notify in every mutator/state setting operation, or whether to depend on clients to call notify at an appropriate time. The flexibility of the notification process, often a useful feature of the pattern, may lead to unintended or unnecessary updates. Another issue lies in the update protocol used by the subject to notify subscribers of changes. The subject often simply passes a reference to itself to the update function of its subscribers, leaving them to infer what has changed about it. If the subject is complex, this may be labour intensive and time consuming. Therefore, it is common practise to define a Change-Manager class to carefully manage these interactions. In our project, we use the Observer pattern to publish changes to variables to the database.

	\subsection{Factory Method Pattern}
	The factory method pattern belongs the grouping of design patterns called creational patterns. These patterns are concerned with the instantiation of objects within a framework and how to maintain quality attributes such as extensibility. These patterns support the Open Closed Principle; closed for modification, open for extension. The main point of the factory method is to defer object instantiation to a method, which is left abstract so that client developers can specify which subclass of the object to instantiate when they implement the abstract class. A classic example would be a class that needs to instantiate some Product but the application designers don't know in advance what type of ConcreteProduct that may be needed. An alternative pattern is the Builder pattern which abstracts out the construction of a complex object and provides the same benefits of deferring object instantiation, albeit with more overhead. We felt that the Builder pattern was too complex for our needs and required more class definitions than was strictly necessary. 

\section{Deployment Options}
The deployment options with regards to this framework are extremely varied. The UML documentation should make it straightforward to realise the abstract design in most object oriented languages, despite the fact that the system was designed with Python in mind as a language platform. One of the Non Functional Requirements for the project was to have a short development cycle, which was the main reason for choosing Python. The language also inherently supports several other quality attributes such as readability, portability and maintainability. Python is gaining popularity and is supported on many platforms and application environments. Any platform capable of running the Python interpreter should be able to run the system, from the ARM-based Raspberry Pi to x64 Unix servers. The abstract framework and sample implementation are fully functional in Python and are both heavily documented in accordance with recommendations in Python Enhancement Proposal 8. 

The Multi tier architecture pattern that we used for the framework was chosen with the quality attributes of interoperability in mind. Organising the system into three distinct layers and carefully managing the classes that link any two layers makes it quite straightforward to deploy each layer on separate machines. By having only one class that bridges each layer gap, the work involved in integrating a transport protocol should be minimised. Several simple existing Python modules handle this type of transport in a simple and intuitive manner, which could easily integrated into an appropriate concrete sub-class. Examples include MySQLdb, Mongodb, httplib, xmlrpclib, pycurl etc. The list goes on and client developers can choose an option they would be comfortable or familiar with, depending on their needs. The bridge pattern used for the presentation layer should also make implementing a platform specific interface pretty trivial, requiring only one new detailed sub-class of GameInterface and a corresponding (simple) sub-class of GamePresentation. 

The current sample implementation of the system, ‘ElectionGame’, is designed as a standalone Python program. In this form, the program is only intended to be deployed in one place i.e the user’s PC/laptop. Any system capable of running python with standard output/input can run the program as is. This type of deployment is illustrated in Fig 1.1. In order to facilitate persistent state, some form of database backend should be added (by fully subclassing DBManager), such as SQLite. This instance would easily run currently on the same system as the program itself, even on the Raspberry Pi. This version could easily be packaged with any Linux based package manager such as RPM for distribution or simply run from source.

Should any developer wish to use the framework for much larger scale deployment, there are many Python application environments that they could choose from. In this current age of the ‘cloud’, web apps are usually the deployment platform of choice. Apart from open source solutions such as Zope, OpenStack and WSGI, there are some interesting proprietary options such as Google’s App Engine. An example of this deployment option is shown in Fig 1.2. The GAE provides a scaleable python environment based on Google’s own application platform, with numerous API’s to access their services, including their cloud storage solution GQL. The interesting thing about GAE is the payment model which is based on resource usage making for a potentially cost effective hosting solution but one that has the potential to scale to millions of users. 

A Python HTML templating system would make for a quick easy web interface implementation. The open source Python web framework provides such functionality as an individual module. The whole Django stack also makes for a quick, simple solution to a scaleable web app deployment of the framework. It provides a convenient Object Relational Mapper to create a database representation of a Python class, with pluggable database modules for several popular data stores. Django is an Model View Controller based framework, a very similar architecture to ours. Each layer of the Django stack functions as independant pluggable python modules. An example deployment based on a Django app is shown in Fig 1.3. The presentation layer is shown as a Linux based application for the Unity UI, which has a Python API. This could be switched for the standard Django web interface based on the template system.
	
\end{document}
